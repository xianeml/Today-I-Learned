# 성능 최적화가 필요한게 아니면 최적화 하지마

- 성능 병목이 있을 경우에만 최적화해라
- 최적화는 비용이 든다. tradeoffs
- 컴퓨터 프로세스와 리소싱 타임이 든다.

# useCallback

함수형 컴포 렌더링 할때마다 그 함수 안에있는 모든 코드를 실행해.

하드코드 변수가 있다해봐. 리액트는 항상 리렌더링할때마다 초기화해. 비용들겠지 작지만

만약 변수에 복잡한 함수를 담는다해봐. 그럼 비용이 더 들겠지

리액트는 이게 새로운건지 아니면 있던건지 몰라.

사실 로직이 작은 부분이라면 상관없어. 우린 오버해서 최적화하지 않을 거야.

근데 화면이 진짜 많은 컴포넌트로 아주 복잡한데 하나하나 다 리렌더링을 하고 있다면? 퍼포먼스 폭탄이 있겠찌

useCallback 은 두개 파라미터를 받아. 첫번째는 캐싱 하고싶은 함수, 두번째는 다시 메모이제이션 하고싶을때 담는 의존성 배열이야

- 메모이제이션: 파라미터가 같으면 함수 아웃풋도 똑같아

이 훅을 보면 의존성 배열에 담긴 애가 변하지 않는 한 함수 로직도 다시 초기화 되지 않고 맨처음 초기화된 함수를 계속 쓸거야.

useCallback에 navigate를 쓰는 경우있잖아. 그때 navigae를 의존성에 넣어야하나? 할텐데, 내 입장은 어차피 navigate() 훅은 변하지 않는 애라 넣을 필요없다. 근데 리액트는 워닝 띄워줄거다. 이건 팀 컨벤션에 따라 진행해라 라고함

### 의존성 배열 활용하기

어떤 상태를 useCallback 에서 사용할때, 상태가 바깥 어딘가에서 업데이트 되었는데도 의존성배열에 안넣어주면 변경된걸 감지를 못함. 그냥 맨처음 초기화된 초기값을 기억해두고 그것만 쭉 함수안에서 사용하는겨. 컴포넌트가 리렌더링될때 useCallback 이 있으면 걔는 새로 초기화 안하고 그냥 지나쳐버림.

# useMemo

복잡한 연산과정 후 값을 리턴 하는 함수를 그냥 변수에 담고 jsx쪽에 사용해버리면 연산이 진행되는 동안에 앱은 동작을 멈춰버려. expensive

useMemo는 값을 기억해. 훅안에 있는 값을 계산해서 어딘가에 기억해. 그래서 얘를 할당한 변수를 사용하면 얘는 항상 기억된 값을 사용하는거야. 의존성 배열이 바뀌기 전까지

리액트는 리렌더링 될때마다 useMemo를 보면 저장된 값을 가져오는겨

의존성 배열 사용하면 의존성 업데이트 되면 따라서 한번더 실행되고

vue computed 같음

# React Devtools Profiling & React Memo

최적화를 위해서 불필요한 리렌더링을 어떻게 알아볼까?

데브툴 프로파일링 사용

녹화버튼 클릭하고 머 동작하고 다시 클릭하면 그동안 렌더링 됬던거 다 보여줌

컴포넌트의 타임라인

Rendered at 에 찍힌 타임 하나하나 눌러보면 그 시점에 어떤 게 렌더링 됬는지 볼수있음

총 몇번 렌더링 되었는지도 이걸보면 알아

전체 컴포넌트가 동시에 리렌더링 될 필요가 없는 부분들을 캐치할 수 있음

react에서 memo 함수를 꺼내

함수형 컴포를 memo로 감싸. 그럼 컴포 자체를 기억해줌

다시 프로파일러 실행해보면 렌더링 안된거 볼수있음
